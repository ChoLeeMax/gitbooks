{"./":{"url":"./","title":"目录结构","keywords":"","body":" 目录结构 js基础算法 Copyright © cholee 2020 粤ICP备18045170号 all right reserved，powered by GitbookFile Modify: 2020-08-21 17:09:11 "},"suanfa/":{"url":"suanfa/","title":"一、js基础算法","keywords":"","body":"数组去重 function qc(arr1) { //创建一个新的数组 let arr = []; //遍历数组arr1 for (let i = 0; i 冒泡排序 function sort(elements) { for (var i = 0; i elements[j + 1]) { var swap = elements[j]; elements[j] = elements[j + 1]; elements[j + 1] = swap; } } } return elements; } var elements = [3, 1, 5, 9, 6]; console.log(sort(elements)); //输出结果[1, 3, 5, 6, 9] 快速排序 var quicksort = function (arr) { if (arr.length 冒泡 //阶乘算法 function jiecheng(num) { if (num == 1) { return 1; } return num * jiecheng(num - 1); } console.log(jiecheng(5)); //斐波拉契题 1， 1， 2， 3， 5， 8， 13， 21 。。。 function fei(num) { if (num == 0 || num == 1) { return 1; } return fei(num - 1) + fei(num - 2); } console.log(fei(5)); Copyright © cholee 2020 粤ICP备18045170号 all right reserved，powered by GitbookFile Modify: 2020-08-17 18:01:48 "},"webpk/":{"url":"webpk/","title":"二、webpack详解","keywords":"","body":" 章节目录 传送门 webpackgitwebpack中文指南webpack中文文档webpack中文网webpack菜鸟教程webpack慕课网 Copyright © cholee 2020 粤ICP备18045170号 all right reserved，powered by GitbookFile Modify: 2020-08-21 17:23:30 "},"webpk/1/":{"url":"webpk/1/","title":"2.1 webpack基础","keywords":"","body":" modules 问题一：什么是模块化？ 模块化是指把一个复杂的系统分解到多个模块以方便编码。 问题二：为什么出现模块化 很久以前，开发网页要通过命名空间的方式来组织代码，例如 jQuery 库把它的 API 都放在了 window.$下，在加载完 jQuery 后其他模块再通过window.$去使用 jQuery。这样做有很多问题，其中包括： 命名空间冲突，两个库可能会使用同一个名称，例如 Zepto 也被放在 window.$下； 无法合理地管理项目的依赖和版本； 无法方便地控制依赖的加载顺序。 当项目变大时这种方式将变得难以维护，需要用模块化的思想来组织代码。 keyconcept 问题一：Webpack 的几个核心概念 Entry：入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入 - Module：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块 - Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割 Loader：模块转换器，用于把模块原内容按照需求转换成新内容。 Plugin：扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情 - Output：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。 construct 问题一：构建的作用及常见功能是什么？ 构建就是当源代码无法直接运行时，通过转化将源代码转换成可执行的 JavaScript、Css、HTML代码。 一般包括如下内容： 代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。 模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。 自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。 代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。 loader 问题一：Loader 机制的作用是什么？ Loader 可以看作具有文件转换功能的翻译员，配置里的 module.rules 数组配置了一组规则，告诉 Webpack 在遇到哪些文件时使用哪些 Loader 去加载和转换。 问题二：css-loader 与 style-loader 的作用 css-loader 读取 CSS 文件 style-loader 把 CSS 内容注入到 JavaScript 里 问题三：配置 Loader 时需要注意的地方？ use 属性的值需要是一个由 Loader 名称组成的数组，Loader 的执行顺序是由后到前的； 每一个 Loader 都可以通过 URL querystring 的方式传入参数，例如 css-loader?minimize 中的 minimize 告诉 css-loader 要开启 CSS 压缩。 plugin 问题一：Plugin（插件）的作用是什么 Plugin 是用来扩展 Webpack 功能的，通过在构建流程里注入钩子实现，它给 Webpack 带来了很大的灵活性。Webpack 是通过plugins属性来配置需要使用的插件列表的。plugins属性是一个数组，里面的每一项都是插件的一个实例，在实例化一个组件时可以通过构造函数传入这个组件支持的配置属性。 问题二：ExtractTextPlugin插件的作用 ExtractTextPlugin插件的作用是提取出 JavaScript 代码里的 CSS 到一个单独的文件。 对此你可以通过插件的filename属性，告诉插件输出的 CSS 文件名称是通过[name]_[contenthash:8].css字符串模版生成的，里面的[name]代表文件名称，[contenthash:8]代表根据文件内容算出的8位 hash 值， 还有很多配置选项可以在ExtractTextPlugin的主页上查到。 devserver 问题一：DevServer开发工具 DevServer 会启动一个 HTTP 服务器用于服务网页请求，同时会帮助启动 Webpack ，并接收 Webpack 发出的文件更变信号，通过 WebSocket 协议自动刷新网页做到实时预览。安装DevServer npm i -D webpack-dev-server 问题二：实时预览 Webpack 在启动时可以开启监听模式，开启监听模式后 Webpack 会监听本地文件系统的变化，发生变化时重新构建出新的结果。Webpack 默认是关闭监听模式的，你可以在启动 Webpack 时通过webpack --watch来开启监听模式。 通过 DevServer 启动的 Webpack 会开启监听模式，当发生变化时重新执行完构建后通知 DevServer。 DevServer 会让 Webpack 在构建出的 JavaScript 代码里注入一个代理客户端用于控制网页，网页和 DevServer 之间通过 WebSocket 协议通信， 以方便 DevServer 主动向客户端发送命令。 DevServer 在收到来自 Webpack 的文件变化通知时通过注入的客户端控制网页刷新。 问题三：什么是模块热替换？ 模块热替换能做到在不重新加载整个网页的情况下，通过将被更新过的模块替换老的模块，再重新执行一次来实现实时预览。模块热替换相对于默认的刷新机制能提供更快的响应和更好的开发体验。 模块热替换默认是关闭的，要开启模块热替换，你只需在启动 DevServer 时带上--hot参数，重启 DevServer 后再去更新文件就能体验到模块热替换的神奇了。 问题四：什么是Source Map 及其使用 Source Map能够提供将压缩文件恢复到源文件原始位置的映射代码的方式。这意味着你可以在优化压缩代码后轻松的进行调试。在编译器输出的代码上进行断点调试是一件辛苦和不优雅的事情， 调试工具可以通过Source Map映射代码，让你在源代码上断点调试。 Source Map使用：Webpack 支持生成 Source Map，只需在启动时带上--devtool source-map参数。 加上参数重启 DevServer 后刷新页面，再打开 Chrome 浏览器的开发者工具，就可在 Sources 栏中看到可调试的源代码了。 Copyright © cholee 2020 粤ICP备18045170号 all right reserved，powered by GitbookFile Modify: 2020-08-21 17:28:59 "},"webpk/2/":{"url":"webpk/2/","title":"2.2 webpack配置","keywords":"","body":" webpack配置 2.2.1 Entry2.2.2 Output2.2.3 Module2.2.4 Resolve2.2.5 DevServer2.2.6 如何整体配置结构 传送门 webpackgit webpack中文指南 webpack中文文档 webpack中文网 webpack菜鸟教程 webpack慕课网 Copyright © cholee 2020 粤ICP备18045170号 all right reserved，powered by GitbookFile Modify: 2020-08-21 17:22:08 "},"webpk/2/Entry.html":{"url":"webpk/2/Entry.html","title":"2.2.1 Entry","keywords":"","body":" 问题一：什么是Entry？ entry是配置模块的入口，可抽象成输入，Webpack 执行构建的第一步将从入口开始搜寻及递归解析出所有入口依赖的模块。 entry配置是必填的，若不填则将导致 Webpack 报错退出 问题二：什么是context？ Webpack 在寻找相对路径的文件时会以context为根目录，context默认为执行启动 Webpack 时所在的当前工作目录。 如果想改变context的默认配置，则可以在配置文件里这样设置它： module.exports = { context: path.resolve(__dirname, 'app') } 注意，context必须是一个绝对路径的字符串。 除此之外，还可以通过在启动 Webpack 时带上参数webpack --context来设置context。 之所以在这里先介绍context，是因为 Entry 的路径和其依赖的模块的路径可能采用相对于context的路径来描述，context会影响到这些相对路径所指向的真实文件。 问题三：Entry 类型有哪些？ Entry 类型可以是以下三种中的一种或者相互组合： 类型 例子 含义 string './app/entry' 入口模块的文件路径，可以是相对路径。 array ['./app/entry1', './app/entry2'] 入口模块的文件路径，可以是相对路径。 object { a: './app/entry-a', b: ['./app/entry-b1', './app/entry-b2']} 配置多个入口，每个入口生成一个 Chunk 如果是array类型，则搭配output.library配置项使用时，只有数组里的最后一个入口文件的模块会被导出。 问题四：Chunk 名称 Webpack 会为每个生成的 Chunk 取一个名称，Chunk 的名称和 Entry 的配置有关： 如果entry是一个string或array，就只会生成一个 Chunk，这时 Chunk 的名称是main； 如果entry是一个object，就可能会出现多个 Chunk，这时 Chunk 的名称是object键值对里键的名称。 问题五：如何配置动态 Entry 假如项目里有多个页面需要为每个页面的入口配置一个 Entry ，但这些页面的数量可能会不断增长，则这时 Entry 的配置会受到到其他因素的影响导致不能写成静态的值。其解决方法是把 Entry 设置成一个函数去动态返回上面所说的配置，代码如下： // 同步函数 entry: () => { return { a:'./pages/a', b:'./pages/b', } }; // 异步函数 entry: () => { return new Promise((resolve)=>{ resolve({ a:'./pages/a', b:'./pages/b', }); }); }; Copyright © cholee 2020 粤ICP备18045170号 all right reserved，powered by GitbookFile Modify: 2020-08-21 17:17:18 "},"webpk/2/Output.html":{"url":"webpk/2/Output.html","title":"2.2.2 Output","keywords":"","body":" filename 配置 output.filename 配置输出文件的名称，为 string 类型。 如果只有一个输出文件，则可以把它写成静态不变的： filename: \"bundle.js\"; 但是在有多个 Chunk 要输出时，就需要借助模版和变量了。前面说到 Webpack 会为每个 Chunk 取一个名称，可以根据 Chunk 的名称来区分输出的文件名： filename: \"[name].js\"; 代码里的[name]代表用内置的 name 变量去替换[name]，这时你可以把它看作一个字符串模块函数， 每个要输出的 Chunk 都会通过这个函数去拼接出输出的文件名称。 内置变量除了 name 还包括： 变量名 含义 id Chunk 的唯一标识，从 0 开始 name Chunk 的名称 hash Chunk 的唯一标识的 Hash 值 chunkhash Chunk 内容的 Hash 值 其中 hash 和 chunkhash 的长度是可指定的，[hash:8]代表取 8 位 Hash 值，默认是 20 位。 注意： ExtractTextWebpackPlugin 插件是使用 contenthash 来代表哈希值而不是 chunkhash， 原因在于 ExtractTextWebpackPlugin 提取出来的内容是代码内容本身而不是由一组模块组成的 Chunk。 chunkFilename 配置 output.chunkFilename 配置无入口的 Chunk 在输出时的文件名称。 chunkFilename 和上面的 filename 非常类似，但 chunkFilename 只用于指定在运行过程中生成的 Chunk 在输出时的文件名称。 常见的会在运行时生成 Chunk 场景有在使用 CommonChunkPlugin、使用 import('path/to/module')动态加载等时。 chunkFilename 支持和 filename 一致的内置变量。 path 配置 output.path 配置输出文件存放在本地的目录，必须是 string 类型的绝对路径。通常通过 Node.js 的 path 模块去获取绝对路径： path: path.resolve(__dirname, \"dist_[hash]\"); publicPath 配置 在复杂的项目里可能会有一些构建出的资源需要异步加载，加载这些异步资源需要对应的 URL 地址。 output.publicPath 配置发布到线上资源的 URL 前缀，为 string 类型。 默认值是空字符串''，即使用相对路径。 这样说可能有点抽象，举个例子，需要把构建出的资源文件上传到 CDN 服务上，以利于加快页面的打开速度。配置代码如下： filename: \"[name]_[chunkhash:8].js\"; publicPath: \"https://cdn.example.com/assets/\"; 这时发布到线上的 HTML 在引入 JavaScript 文件时就需要： 使用该配置项时要小心，稍有不慎将导致资源加载 404 错误。 output.path 和 output.publicPath 都支持字符串模版，内置变量只有一个：hash 代表一次编译操作的 Hash 值。 Copyright © cholee 2020 粤ICP备18045170号 all right reserved，powered by GitbookFile Modify: 2020-08-21 17:35:52 "},"webpk/2/Module.html":{"url":"webpk/2/Module.html","title":"2.2.3 Module","keywords":"","body":"Copyright © cholee 2020 粤ICP备18045170号 all right reserved，powered by GitbookFile Modify: 2020-08-21 16:58:54 "},"webpk/2/Resolve.html":{"url":"webpk/2/Resolve.html","title":"2.2.4 Resolve","keywords":"","body":"Copyright © cholee 2020 粤ICP备18045170号 all right reserved，powered by GitbookFile Modify: 2020-08-21 16:58:54 "},"webpk/2/DevServer.html":{"url":"webpk/2/DevServer.html","title":"2.2.5 DevServer","keywords":"","body":"Copyright © cholee 2020 粤ICP备18045170号 all right reserved，powered by GitbookFile Modify: 2020-08-21 16:58:54 "},"webpk/2/Config.html":{"url":"webpk/2/Config.html","title":"2.2.6 如何整体配置结构","keywords":"","body":"Copyright © cholee 2020 粤ICP备18045170号 all right reserved，powered by GitbookFile Modify: 2020-08-21 16:58:54 "},"webpk/4/":{"url":"webpk/4/","title":"2.4 webpack优化","keywords":"","body":"Copyright © cholee 2020 粤ICP备18045170号 all right reserved，powered by GitbookFile Modify: 2020-08-20 17:48:07 "},"webpk/5/":{"url":"webpk/5/","title":"2.5 webpack原理","keywords":"","body":"Copyright © cholee 2020 粤ICP备18045170号 all right reserved，powered by GitbookFile Modify: 2020-08-20 17:48:07 "}}